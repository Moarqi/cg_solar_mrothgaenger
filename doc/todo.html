<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Solar System: Todo List</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxy.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Solar System
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">Todo List </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><dl class="reflist">
<dt><a class="anchor" id="_todo000001"></a>Member <a class="el" href="classBillboard.html#a391770a38d07b837a182e3d0ca28fb34">Billboard::computeBillboardAngles</a>  (const vec3 &amp;billboard_to_eye)</dt>
<dd>update <code>angle_x_</code> and <code>angle_y_</code> of the billboard.<ul>
<li>Make sure that the vector <code>billboard_to_eye</code> is always perpendicular to the billboard's plane</li>
<li>The two angles are related to the polar and azimuthal angle of a sphere (see <a href="https://en.wikipedia.org/wiki/Spherical_coordinate_system">https://en.wikipedia.org/wiki/Spherical_coordinate_system</a>)</li>
<li><a href="https://neutrium.net/mathematics/converting-between-spherical-and-cartesian-co-ordinate-systems/">https://neutrium.net/mathematics/converting-between-spherical-and-cartesian-co-ordinate-systems/</a> shows how to convert cartesian coordinates to spherical ones.</li>
<li>The function <code>atan2(...)</code> is already defined.</li>
<li>There is an offset between the spherical angles and the needed angles. Try different 90Â° offsets until you get the desired result. Hint: It helps to set the look_at to the sun (key 1) and print <code><a class="el" href="classSolar__viewer.html#afe0f50221ea1464e4b1a9c79071bcac0" title="rotation in x direction around the planet/sun from the original point ">Solar_viewer::x_angle_</a></code> and <code><a class="el" href="classSolar__viewer.html#aec80e0da0a52b108b1b7223d2a974860" title="rotation in y direction around the planet/sun from the original point ">Solar_viewer::y_angle_</a></code> to find the right offset. In this case, those angles should be identical to <code>angle_x_</code> and <code>angle_y_</code>.  </li>
</ul>
</dd>
<dt><a class="anchor" id="_todo000002"></a>Member <a class="el" href="classSaturn__Rings.html#aa081de4d0dfc0003006839fefef90d92">Saturn_Rings::initGlArrays</a>  ()</dt>
<dd>(Bonus Task) Define the saturn ring mesh.<ul>
<li>Fill the vectors defined above. Therefore, find a way to define a ring by triangles.</li>
<li><code>inner_radius_</code> and <code>outer_radius_</code> define the size of the ring.</li>
<li><code>resolution_</code> should determine how many vertices build the outer and inner boundary. So, if you decrease <code>resolution_</code> to 3 for example, the ring should look like a triangle with a hole in the middle.</li>
<li><code>textures/saturn_rings.png</code> is the texture we use for the ring. Think about how you have to define the texcoords <code>u_coords</code> and <code>v_coords</code> to get the desired effect. </li>
</ul>
</dd>
<dt><a class="anchor" id="_todo000003"></a>Member <a class="el" href="classShip.html#a34832cdc6cb1c67fa346b6903da62c81">Ship::load_model</a>  (const char *filename)</dt>
<dd>Implement a simple .off reader. <code>.off</code> is a simple text-based mesh format<ol type="1">
<li>open /meshes/cube.off with a text editor and try to find out how an <code>.off</code> file saves the mesh information (or look it up in the internet, but we recommand doing the former first)</li>
<li>use the input filestream <code>ifs</code> to parse the file in <code>vertices_</code> and <code>indices</code> (Maybe you should find out how to use ifstream objects first) </li>
</ol>
</dd>
<dt><a class="anchor" id="_todo000007"></a>Member <a class="el" href="classSolar__viewer.html#af6b468fb543b9c9ed466fe1687f1aff8">Solar_viewer::draw_scene</a>  (mat4 &amp;_projection, mat4 &amp;_view)</dt>
<dd>Implement a rotating solar system.<ol type="1">
<li>Start by positioning all celestial bodies considered (mercury, venus, earth, mars, jupiter and the earth's moon) along one axis and render each with its accompanying texture. Hints:<ul>
<li>The distance from the rotation's center and the scale to be applied is given for each instance of <code><a class="el" href="classPlanet.html" title="default class for the planet ">Planet</a></code> (that class is used for all bodies, including the moon, even though the moon is no planet).</li>
<li>Consider disabling face culling in order to render backfaces.</li>
<li>See glmath.h/cpp for an overview about implemented matrices.</li>
<li><code><a class="el" href="classPlanet.html#a5179a41d97c015b373b6e8a3f4458f64" title="distance of the planet from the sun (=origin) ">Planet::distance_</a></code> stores the distance to the center of the sun except for the moon (here distance to center of earth).</li>
<li>It will be a lot of copy and paste. But you can also use the vector <code>planets_</code> if you like. Note that its elements are pointers (use -&gt; instead of .) </li>
</ul>
</li>
</ol>
</dd>
<dt><a class="anchor" id="_todo000004"></a>Member <a class="el" href="classSolar__viewer.html#aaf4e3bd2fd0dea72ffafe050a3c2ef7f">Solar_viewer::keyboard</a>  (int key, int scancode, int action, int mods)</dt>
<dd>Implement the ability to change the viewer's distance to the celestial body.<ul>
<li>key 9 should increase and key 0 should decrease the <code>dist_factor_</code></li>
<li>make sure that <code>2.5 &lt; dist_factor_ &lt; 20.0</code> Note: the mouse wheel also activates zooming automatically, if you finish this task.  </li>
</ul>
</dd>
<dt><a class="anchor" id="_todo000005"></a>Member <a class="el" href="classSolar__viewer.html#ab0c48ceb8d58aefee8c5528c9efa6412">Solar_viewer::paint</a>  ()</dt>
<dd><p class="startdd">Implement a kind of navigation through the solar system.</p><ul>
<li>Allow rotation of the camera, by modifying the view matrix. <code>x_angle_</code> and <code>y_angle</code> hold the neccesary information and are updated when certain keys are pressed (see <code><a class="el" href="classSolar__viewer.html#aaf4e3bd2fd0dea72ffafe050a3c2ef7f" title="keyboard interaction ">Solar_viewer::keyboard</a>(...)</code>). <code>dist_factor_</code> is the number of radii from the center of the planet to the camera.</li>
<li>If <code>x_angle_</code> and <code>y_angle_</code>are zero, the camera should be translated in positive z-direction from the planet's center.</li>
<li>The camera should always face the planet's center. The rotation is meant to be around the planet'center not around the camera's center.</li>
<li>If one of the keys <code>1</code> to <code>8</code> is pressed, the camera should face the respective celestial body (compare <code><a class="el" href="classSolar__viewer.html#aaf4e3bd2fd0dea72ffafe050a3c2ef7f" title="keyboard interaction ">Solar_viewer::keyboard</a>(...)</code>). <code>look_at_</code> is updated in this case and stores a pointer to the current looked at planet.</li>
<li>To support changing distance to the body see <code><a class="el" href="classSolar__viewer.html#aaf4e3bd2fd0dea72ffafe050a3c2ef7f" title="keyboard interaction ">Solar_viewer::keyboard</a>(...)</code></li>
<li>If you are in the spaceship (member in_ship_), the camera should hover slightly behind it and rotate along with it. Hint: To understand what effect is desired, it helps to watch the solution videos. </li>
</ul>
<p class="enddd">Implement stereo rendering.</p><ol type="1">
<li>Calculate parameters for the left and right eye.</li>
<li>Use <code>mat4::frustum(...)</code> to construct your two projection matrices.</li>
<li>Translate the <code>view</code> matrix to get one for the left and one for the right eye.</li>
</ol>
<ol type="1">
<li>Render two images, one for the left and one for the right eye using <code>draw_scene(...)</code>;.<ul>
<li>For <code>view_mode_ == STEREO_ANAGLYPH</code>, look up <code>glColorMask</code> and use it to enable filtering of red/cyan. Setting the rendering to greyscale (by pressing <code>g</code>) will show the effect best.</li>
<li>In view_mode_ == STEREO_SPLIT, you can use <code>glViewport</code> to render the left-eye image on the left (or upper) screen half and the right-eye image on the right (or lower) screen half.</li>
<li>Do not forget to reset viewport and color mask. </li>
</ul>
</li>
</ol>
</dd>
<dt><a class="anchor" id="_todo000008"></a>Member <a class="el" href="classTexture.html#ac1736429814a7b4c0e1ecbddc729c497">Texture::createSunglowTexture</a>  ()</dt>
<dd>Setup the texture for the sun billboard by filling <code>img</code> with color values.<ul>
<li>Draw an opaque (alpha == 1) circle with a 150 pixel radius in its middle</li>
<li>Outside that circle the texture should become more and more transparent (alpha &lt; 1) to mimic a nice glow effect</li>
<li>Make sure that your texture is fully transparent (alpha == 0) at its borders to avoid seeing visible edges</li>
<li>Experiment with the color and with how fast you change the transparency until the effect satisfies you </li>
</ul>
</dd>
</dl>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
